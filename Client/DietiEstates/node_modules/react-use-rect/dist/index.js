"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  useRect: () => useRect,
  useWindowOn: () => useWindowOn
});
module.exports = __toCommonJS(src_exports);

// src/use-rect.ts
var import_react = require("react");
function useRect(dispatchChange, { resize = false } = {}) {
  const dispatchChangeRef = (0, import_react.useRef)(dispatchChange);
  (0, import_react.useEffect)(() => {
    dispatchChangeRef.current = dispatchChange;
  }, [dispatchChange]);
  const resizeRef = (0, import_react.useRef)(resize);
  (0, import_react.useEffect)(() => {
    resizeRef.current = resize;
    setupResizeObserver();
  }, [resize]);
  const elementRef = (0, import_react.useRef)(null);
  const setElement = (0, import_react.useCallback)((element) => {
    if (element === elementRef.current) {
      return;
    }
    elementRef.current = element;
    revalidate();
    setupResizeObserver();
  }, []);
  const rectRef = (0, import_react.useRef)(null);
  const revalidate = (0, import_react.useCallback)(
    ({ force = false } = {}) => {
      if (!elementRef.current) {
        return;
      }
      const nextRect = elementRef.current.getBoundingClientRect();
      if (force || shouldDispatchRectChange(rectRef.current, nextRect)) {
        rectRef.current = nextRect;
        const { bottom, height, left, right, top, width, x, y } = nextRect;
        dispatchChangeRef.current({
          bottom,
          height,
          left,
          right,
          top,
          width,
          x,
          y
        });
      }
    },
    []
  );
  const resizeObserverRef = (0, import_react.useRef)(null);
  const setupResizeObserver = (0, import_react.useCallback)(() => {
    if (resizeObserverRef.current) {
      resizeObserverRef.current.disconnect();
      resizeObserverRef.current = null;
    }
    if (elementRef.current && resizeRef.current) {
      resizeObserverRef.current = new ResizeObserver(() => revalidate());
      resizeObserverRef.current.observe(elementRef.current);
    }
  }, [revalidate]);
  (0, import_react.useEffect)(revalidate);
  return [setElement, revalidate];
}
var RECT_KEYS = [
  "bottom",
  "height",
  "left",
  "right",
  "top",
  "width",
  "x",
  "y"
];
function shouldDispatchRectChange(rect, nextRect) {
  return !rect || rect !== nextRect && RECT_KEYS.some((key) => rect[key] !== nextRect[key]);
}

// src/use-window-on.ts
var import_react2 = require("react");
function useWindowOn(eventType, callback) {
  const callbackRef = (0, import_react2.useRef)(callback);
  (0, import_react2.useEffect)(() => {
    callbackRef.current = callback;
  });
  (0, import_react2.useEffect)(() => {
    if (typeof window === "undefined") {
      return void 0;
    }
    const listener = (event) => {
      callbackRef.current(event);
    };
    const options = {
      capture: true,
      passive: true
    };
    window.addEventListener(eventType, listener, options);
    return () => {
      window.removeEventListener(eventType, listener, options);
    };
  }, [eventType]);
}
