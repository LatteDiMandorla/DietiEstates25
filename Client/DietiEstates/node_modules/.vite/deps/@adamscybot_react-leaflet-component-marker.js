import {
  Marker,
  require_leaflet_src
} from "./chunk-5H3QVFRP.js";
import {
  require_react_dom
} from "./chunk-XRPIAATO.js";
import {
  require_react
} from "./chunk-D2P3IO6H.js";
import {
  __commonJS,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@adamscybot/react-leaflet-component-marker/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/@adamscybot/react-leaflet-component-marker/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType2(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType2;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/@adamscybot/react-leaflet-component-marker/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/@adamscybot/react-leaflet-component-marker/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/@adamscybot/react-leaflet-component-marker/dist/Marker.js
var import_react2 = __toESM(require_react(), 1);
var import_react_is = __toESM(require_react_is(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_leaflet = __toESM(require_leaflet_src(), 1);

// node_modules/@adamscybot/react-leaflet-component-marker/node_modules/react-reverse-portal/dist/web/index.js
var React = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ELEMENT_TYPE_HTML = "html";
var ELEMENT_TYPE_SVG = "svg";
var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
var validateElementType = function(domElement, elementType) {
  var _a, _b, _c;
  var ownerDocument = (_a = domElement.ownerDocument) !== null && _a !== void 0 ? _a : document;
  var ownerWindow = (_c = (_b = ownerDocument.defaultView) !== null && _b !== void 0 ? _b : ownerDocument.parentWindow) !== null && _c !== void 0 ? _c : window;
  if (elementType === ELEMENT_TYPE_HTML) {
    return domElement instanceof ownerWindow.HTMLElement;
  }
  if (elementType === ELEMENT_TYPE_SVG) {
    return domElement instanceof ownerWindow.SVGElement;
  }
  throw new Error('Unrecognized element type "'.concat(elementType, '" for validateElementType.'));
};
var createPortalNode = function(elementType, options) {
  var initialProps = {};
  var parent;
  var lastPlaceholder;
  var element;
  if (elementType === ELEMENT_TYPE_HTML) {
    element = document.createElement("div");
  } else if (elementType === ELEMENT_TYPE_SVG) {
    element = document.createElementNS(SVG_NAMESPACE, "g");
  } else {
    throw new Error('Invalid element type "'.concat(elementType, '" for createPortalNode: must be "html" or "svg".'));
  }
  if (options && typeof options === "object") {
    for (var _i = 0, _a = Object.entries(options.attributes); _i < _a.length; _i++) {
      var _b = _a[_i], key = _b[0], value = _b[1];
      element.setAttribute(key, value);
    }
  }
  var portalNode = {
    element,
    elementType,
    setPortalProps: function(props) {
      initialProps = props;
    },
    getInitialPortalProps: function() {
      return initialProps;
    },
    mount: function(newParent, newPlaceholder) {
      if (newPlaceholder === lastPlaceholder) {
        return;
      }
      portalNode.unmount();
      if (newParent !== parent) {
        if (!validateElementType(newParent, elementType)) {
          throw new Error('Invalid element type for portal: "'.concat(elementType, '" portalNodes must be used with ').concat(elementType, " elements, but OutPortal is within <").concat(newParent.tagName, ">."));
        }
      }
      newParent.replaceChild(portalNode.element, newPlaceholder);
      parent = newParent;
      lastPlaceholder = newPlaceholder;
    },
    unmount: function(expectedPlaceholder) {
      if (expectedPlaceholder && expectedPlaceholder !== lastPlaceholder) {
        return;
      }
      if (parent && lastPlaceholder) {
        parent.replaceChild(lastPlaceholder, portalNode.element);
        parent = void 0;
        lastPlaceholder = void 0;
      }
    }
  };
  return portalNode;
};
var InPortal = (
  /** @class */
  function(_super) {
    __extends(InPortal2, _super);
    function InPortal2(props) {
      var _this = _super.call(this, props) || this;
      _this.addPropsChannel = function() {
        Object.assign(_this.props.node, {
          setPortalProps: function(props2) {
            _this.setState({ nodeProps: props2 });
          }
        });
      };
      _this.state = {
        nodeProps: _this.props.node.getInitialPortalProps()
      };
      return _this;
    }
    InPortal2.prototype.componentDidMount = function() {
      this.addPropsChannel();
    };
    InPortal2.prototype.componentDidUpdate = function() {
      this.addPropsChannel();
    };
    InPortal2.prototype.render = function() {
      var _this = this;
      var _a = this.props, children = _a.children, node = _a.node;
      return ReactDOM.createPortal(React.Children.map(children, function(child) {
        if (!React.isValidElement(child))
          return child;
        return React.cloneElement(child, _this.state.nodeProps);
      }), node.element);
    };
    return InPortal2;
  }(React.PureComponent)
);
var OutPortal = (
  /** @class */
  function(_super) {
    __extends(OutPortal2, _super);
    function OutPortal2(props) {
      var _this = _super.call(this, props) || this;
      _this.placeholderNode = React.createRef();
      _this.passPropsThroughPortal();
      return _this;
    }
    OutPortal2.prototype.passPropsThroughPortal = function() {
      var propsForTarget = Object.assign({}, this.props, { node: void 0 });
      this.props.node.setPortalProps(propsForTarget);
    };
    OutPortal2.prototype.componentDidMount = function() {
      var node = this.props.node;
      this.currentPortalNode = node;
      var placeholder = this.placeholderNode.current;
      var parent = placeholder.parentNode;
      node.mount(parent, placeholder);
      this.passPropsThroughPortal();
    };
    OutPortal2.prototype.componentDidUpdate = function() {
      var node = this.props.node;
      if (this.currentPortalNode && node !== this.currentPortalNode) {
        this.currentPortalNode.unmount(this.placeholderNode.current);
        this.currentPortalNode.setPortalProps({});
        this.currentPortalNode = node;
      }
      var placeholder = this.placeholderNode.current;
      var parent = placeholder.parentNode;
      node.mount(parent, placeholder);
      this.passPropsThroughPortal();
    };
    OutPortal2.prototype.componentWillUnmount = function() {
      var node = this.props.node;
      node.unmount(this.placeholderNode.current);
      node.setPortalProps({});
    };
    OutPortal2.prototype.render = function() {
      return React.createElement("div", { ref: this.placeholderNode });
    };
    return OutPortal2;
  }(React.PureComponent)
);
var createHtmlPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_HTML);
var createSvgPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_SVG);

// node_modules/@adamscybot/react-leaflet-component-marker/dist/lib/useCoordsFromPointExpression.js
var import_react = __toESM(require_react(), 1);
var getCoordsFromPointExpression = (expression) => {
  if (!expression)
    return [];
  if (Array.isArray(expression)) {
    return expression;
  } else {
    return [expression.x, expression.y];
  }
};
var useCoordsFromPointExpression = (expression) => (0, import_react.useMemo)(() => getCoordsFromPointExpression(expression), [expression]);

// node_modules/@adamscybot/react-leaflet-component-marker/dist/lib/logging.js
var logString = (str) => `[react-leaflet-component-marker] ${str}`;
var logCodedString = (code, str) => logString(`[${code}] ${str}`);

// node_modules/@adamscybot/react-leaflet-component-marker/dist/Marker.js
var DEFAULT_ICON_SIZE = [0, 0];
var ComponentMarker = (0, import_react2.forwardRef)(({ eventHandlers: providedEventHandlers, icon: providedIcon, componentIconOpts: { layoutMode = "fit-content", disableClickPropagation, disableScrollPropagation, rootDivOpts, rootSizeWarning } = {}, ...otherProps }, ref) => {
  const [markerRendered, setMarkerRendered] = (0, import_react2.useState)(false);
  const [, setChangeCount] = (0, import_react2.useState)(0);
  const id = "marker-" + (0, import_react2.useId)();
  const portalNode = import_react2.default.useMemo(() => createHtmlPortalNode({
    attributes: {
      "data-react-component-marker": "portal-parent",
      style: "width:100%;height:100%;"
    }
  }), []);
  (0, import_react2.useEffect)(() => {
    if (rootSizeWarning !== false && layoutMode === "fit-parent" && (rootDivOpts == null ? void 0 : rootDivOpts.iconSize) === void 0) {
      console.warn(logCodedString("UNBOUND_FIT_PARENT", `The 'componentIconOpts.rootDivOpts.iconSize' option was not set but 'componentIconOpts.layoutMode' was set to 'fit-parent'. This means your React component will not be properly bound by the parent.
        
To disable this warning set 'componentIconOpts.rootSizeWarning' to false.`));
    }
  }, [layoutMode, rootSizeWarning, rootDivOpts == null ? void 0 : rootDivOpts.iconSize]);
  const { attribution, className, iconAnchor, iconSize = DEFAULT_ICON_SIZE, pane, popupAnchor, tooltipAnchor } = rootDivOpts ?? {};
  const iconDeps = [
    id,
    layoutMode,
    attribution,
    className,
    pane,
    Boolean(disableClickPropagation),
    Boolean(disableScrollPropagation),
    ...useCoordsFromPointExpression(iconSize),
    ...useCoordsFromPointExpression(iconAnchor),
    ...useCoordsFromPointExpression(popupAnchor),
    ...useCoordsFromPointExpression(tooltipAnchor)
  ];
  const icon = (0, import_react2.useMemo)(() => {
    const parentStyles = layoutMode === "fit-content" ? "width: min-content; transform: translate(-50%, -50%)" : "width: 100%; height: 100%";
    return (0, import_leaflet.divIcon)({
      html: `<div data-react-component-marker="root" style="${parentStyles}" id="${id}"></div>`,
      ...iconSize ? { iconSize } : [],
      ...iconAnchor ? { iconAnchor } : [],
      ...popupAnchor ? { popupAnchor } : [],
      ...tooltipAnchor ? { tooltipAnchor } : [],
      pane,
      attribution,
      className
    });
  }, iconDeps);
  (0, import_react2.useLayoutEffect)(() => {
    setChangeCount((prev) => prev + 1);
  }, [icon]);
  const handleAddEvent = (0, import_react2.useCallback)((...args) => {
    setMarkerRendered(true);
    if (providedEventHandlers == null ? void 0 : providedEventHandlers.add)
      providedEventHandlers.add(...args);
  }, [providedEventHandlers == null ? void 0 : providedEventHandlers.add]);
  const handleRemoveEvent = (0, import_react2.useCallback)((...args) => {
    setMarkerRendered(false);
    if (providedEventHandlers == null ? void 0 : providedEventHandlers.remove)
      providedEventHandlers.remove(...args);
  }, [providedEventHandlers == null ? void 0 : providedEventHandlers.remove]);
  const eventHandlers = (0, import_react2.useMemo)(() => ({
    ...providedEventHandlers,
    add: handleAddEvent,
    remove: handleRemoveEvent
  }), [providedEventHandlers, handleAddEvent, handleRemoveEvent]);
  let portalTarget = null;
  if (markerRendered) {
    portalTarget = document.getElementById(id);
  }
  (0, import_react2.useEffect)(() => {
    if (!portalTarget)
      return;
    if (disableClickPropagation) {
      import_leaflet.DomEvent.disableClickPropagation(portalTarget);
    }
    if (disableScrollPropagation) {
      import_leaflet.DomEvent.disableScrollPropagation(portalTarget);
    }
  }, [portalTarget, disableClickPropagation, disableScrollPropagation]);
  return import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(Marker, { ref, ...otherProps, eventHandlers, icon }),
    markerRendered && portalTarget !== null && import_react2.default.createElement(
      import_react2.default.Fragment,
      null,
      import_react2.default.createElement(InPortal, { node: portalNode }, providedIcon),
      (0, import_react_dom.createPortal)(import_react2.default.createElement(OutPortal, { node: portalNode }), portalTarget)
    )
  );
});
var Marker2 = (0, import_react2.forwardRef)(({ icon: Icon, componentIconOpts, ...otherProps }, ref) => {
  const validElement = (0, import_react2.isValidElement)(Icon);
  const validComponent = (0, import_react_is.isValidElementType)(Icon);
  (0, import_react2.useEffect)(() => {
    if (!validElement && !validComponent && componentIconOpts !== void 0 && componentIconOpts.unusedOptsWarning !== false) {
      console.warn(logCodedString("UNUSED_OPTIONS", `The 'componentIconOpts' prop was set but the 'icon' prop was not set to a React component or element. These options will be unused.
        
  To disable this warning set 'componentIconOpts.unusedOptsWarning' to false.`));
    }
  }, [
    componentIconOpts,
    componentIconOpts == null ? void 0 : componentIconOpts.unusedOptsWarning,
    validElement,
    validComponent
  ]);
  if (validElement) {
    return import_react2.default.createElement(ComponentMarker, { ref, icon: Icon, componentIconOpts, ...otherProps });
  }
  if (validComponent) {
    return import_react2.default.createElement(ComponentMarker, { ref, icon: import_react2.default.createElement(Icon, null), componentIconOpts, ...otherProps });
  }
  return import_react2.default.createElement(Marker, { ref, icon: Icon, ...otherProps });
});
export {
  Marker2 as Marker
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@adamscybot_react-leaflet-component-marker.js.map
