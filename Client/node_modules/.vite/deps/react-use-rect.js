import {
  require_react
} from "./chunk-D2P3IO6H.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/react-use-rect/dist/index.esm.js
var import_react = __toESM(require_react());
var import_react2 = __toESM(require_react());
function useRect(dispatchChange, { resize = false } = {}) {
  const dispatchChangeRef = (0, import_react.useRef)(dispatchChange);
  (0, import_react.useEffect)(() => {
    dispatchChangeRef.current = dispatchChange;
  }, [dispatchChange]);
  const resizeRef = (0, import_react.useRef)(resize);
  (0, import_react.useEffect)(() => {
    resizeRef.current = resize;
    setupResizeObserver();
  }, [resize]);
  const elementRef = (0, import_react.useRef)(null);
  const setElement = (0, import_react.useCallback)((element) => {
    if (element === elementRef.current) {
      return;
    }
    elementRef.current = element;
    revalidate();
    setupResizeObserver();
  }, []);
  const rectRef = (0, import_react.useRef)(null);
  const revalidate = (0, import_react.useCallback)(
    ({ force = false } = {}) => {
      if (!elementRef.current) {
        return;
      }
      const nextRect = elementRef.current.getBoundingClientRect();
      if (force || shouldDispatchRectChange(rectRef.current, nextRect)) {
        rectRef.current = nextRect;
        const { bottom, height, left, right, top, width, x, y } = nextRect;
        dispatchChangeRef.current({
          bottom,
          height,
          left,
          right,
          top,
          width,
          x,
          y
        });
      }
    },
    []
  );
  const resizeObserverRef = (0, import_react.useRef)(null);
  const setupResizeObserver = (0, import_react.useCallback)(() => {
    if (resizeObserverRef.current) {
      resizeObserverRef.current.disconnect();
      resizeObserverRef.current = null;
    }
    if (elementRef.current && resizeRef.current) {
      resizeObserverRef.current = new ResizeObserver(() => revalidate());
      resizeObserverRef.current.observe(elementRef.current);
    }
  }, [revalidate]);
  (0, import_react.useEffect)(revalidate);
  return [setElement, revalidate];
}
var RECT_KEYS = [
  "bottom",
  "height",
  "left",
  "right",
  "top",
  "width",
  "x",
  "y"
];
function shouldDispatchRectChange(rect, nextRect) {
  return !rect || rect !== nextRect && RECT_KEYS.some((key) => rect[key] !== nextRect[key]);
}
function useWindowOn(eventType, callback) {
  const callbackRef = (0, import_react2.useRef)(callback);
  (0, import_react2.useEffect)(() => {
    callbackRef.current = callback;
  });
  (0, import_react2.useEffect)(() => {
    if (typeof window === "undefined") {
      return void 0;
    }
    const listener = (event) => {
      callbackRef.current(event);
    };
    const options = {
      capture: true,
      passive: true
    };
    window.addEventListener(eventType, listener, options);
    return () => {
      window.removeEventListener(eventType, listener, options);
    };
  }, [eventType]);
}
export {
  useRect,
  useWindowOn
};
//# sourceMappingURL=react-use-rect.js.map
